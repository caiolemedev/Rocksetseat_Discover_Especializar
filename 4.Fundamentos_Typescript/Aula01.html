<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Especializar 4.1 - Especializar Typescript</title>
  </head>
  <body>
    <h1>Especializar Typescript</h1>

    <h2>Abertura</h2>
    <p>Ajudar na produtividade e tornar o código mais consistente</p>

    <h2>O que é o Typescript</h2>
    <p>
      Foi criado para trazer um superset de tipagens para o JS. O JS não é uma
      linguagem fortemente tipada, portanto alguns erros podem passar durante o
      desenvolvimento da aplicação. O Typescript limita este tipo de erro ao
      desenvolvimento e mantém a consistência da aplicação. Melhora o
      desenvolvimento em times compartilhando funções e melhorando a
      produtividade. No final, será tudo transferido e compilado do Typescript
      para JS.
    </p>

    <h2>Por que utilizar Typescript?</h2>
    <p>
      Quando passamos números como texto para operações matemáticas o JS irá
      concatenar os valores, como se fossem texto, assim o resultado de uma soma
      onde um dos itens é texto seria um valor errado. Exemplo: 1+2 seria 12.
      Podemos também errar dividindo um número por um array. Podemos errar
      também tentando acessar parâmetros ou funções que não existem em um tipo
      de variável específico.
    </p>

    <h2>Typescript Playground</h2>
    <p>
      No site oficial do Typescript podemos acessar o Playground para treinarmos
      a utilização do mesmo e aprendermos um pouco. Nele podemos rodar a
      aplicação ou ver o código TS sendo traduzido para JS.
    </p>

    <h2>Verificação tipo estático</h2>
    <p>
      O TS é um verificador de tipo estático, ou seja, verifica as expectativas
      da função e variáveis antes de executar o programa. Fizemos alguns testes
      tentando executar funções, acessar propriedades e funções inexistentes e
      passar parâmetros do tipo errado para a função.
    </p>

    <h2>Compilação</h2>
    <p>
      Todo código TS irá se tornar JS após ser compilado. Criamos uma função
      simples e executamos para verificar o resultado, quando acessamos o código
      JS podemos notar que a tipagem nos parâmetros da função foram removidos na
      compilação. Podemos usar a combinação de tipagem com verificação de nulos
      no TS de forma simples, mas o código gerado no JS é totalmente diferente.
    </p>

    <h2>Tipagem Explícita</h2>
    <p>
      Como o TS é uma linguagem com tipagem explícita no próprio desenvolvimento
      podemos verificar o tipo e qual variável estamos preenchendo ao
      executarmos uma função.
    </p>

    <h2>Any</h2>
    <p>
      Podemos tipar uma variável como any para não deixar a declaração explícita
      podendo assim colocar qualquer valor dentro da variável, como texto,
      number, array, boolean, etc. Da mesma forma na função podemos usar any
      para tipar um parâmetro, mas o TS já avisa que o uso do any é perigoso.
      Devemos ter muito cuidado com o uso para não termos erros que teríamos no
      JS, perdemos a essência do TS quando usamos any.
    </p>

    <h2>Interferêcia de tipos</h2>
    <p>
      Usamos o dois pontos após o nome da variável para indicar qual tipo de
      dado deverá ser inserido nela. A inferência de tipo é quando o TS
      identifica o tipo de dado que colocamos na veriável e atribui um tipo a
      variável (declaração implícita), o tipo é inferido pelo TS.
    </p>

    <h2>Tipos Primitivos</h2>
    <p>No TS podemos usar os tipos primitivos como boolean, number e string.</p>

    <h2>Matrizes</h2>
    <p>
      Podemos também definir tipagem para vetores ou matrizes, normalmemnte
      usarmos as chaves após o tipo para indicar que estamos tipando uma
      variável que será um array. Exemplo: let numbers: number[].
    </p>

    <h2>Funções</h2>
    <p>
      Se uma função não tem retorno o TS vai identifica-la como void, podemos
      também declarar explicitamente e caso colocarmos um retorno nela o TS irá
      apontar um erro. Se declararmos o tipo de retorno explicitamente o TS
      também irá identificar caso o retorno em si não seja compatível. Colocamos
      a tipagem explícita da função após seus parâmetros e antes do conteúdo,
      ex: function showMessage(message: string): string { return message; }
    </p>

    <h2>Union</h2>
    <p>
      O operador Union permite que a variável aceite um tipo OU o outro tipo no
      seu impout, para isso usamos o pipe entre os tipos da variável. Exemplo:
      function printUserId(id: number | string) {}.
    </p>

    <h2>Generics</h2>
    <p>
      É utilizado de forma similar ao Union, para deixar a tipagem mais
      flexível. Ele permite deixar a tipagem aberta até o momento da declaração
      e a partir daquele momento ele só irá aceitar aquele tipo de valor na
      variável. Normalmente usamos S para state, T para type, K para key, V para
      value e E para element. Na execução da função usamos o identificador de
      tipo e podemos também na declaração dela podemos extender (extends) para
      outros tipos, ele seguirá dando alerta. Exemplo que será colocado entre os
      sinais de maior e menor: T extends string | number = string.
    </p>

    <h2>Type</h2>
    <p>
      Até aqui declaramos os tipos direto na variável, mas podemos criar um tipo
      usando a declaração type e atribuir quais tipos desejamos usar para
      utilizar depois. Sempre criamos tipos iniciando com letra maiúscula.
      Exemplo: type IdType = string |number|undefined.
    </p>

    <h2>Type Assertions</h2>
    <p>
      Usamos quando o TS não sabe exatamente qual tipo de dados estamos usando
      mas podemos colocar de maneira forçada ou conversão qual o tipo do dado.
      Usamos normalmente quando tratamos com APIs e o TS não sabe qual dado
      estamos recebendo. Podemos fazer com objeto colocando o tipo de cada
      propriedade do mesmo.
    </p>

    <h2>Objetos</h2>
    <p>
      Podemos criar tipagem para objetos informando qual o tipo de cada
      propriedade do mesmo, listando quando declaramos o type. Posteriormente
      podemos utilizar como desejarmos no código e o TS irá nos auxiliar no
      preenchimento das informações bem como identificando erros de tipos.
    </p>

    <h2>Opcional</h2>
    <p>
      Dentro do objeto podemos colocar uma propriedade como opcional, basta
      colocarmos uma interrogação antes dos dois pontos no type.
    </p>

    <h2>Intersecção de Tipos</h2>
    <p>
      Podemos juntar dois tipos via comando e comercial, dessa forma: type =
      PlayerInfo = User & Char. Assim quando colocarmos o tipo da variável como
      PlayerInfo o TS irá solicitar o preenchimento de todas as informações de
      User e Char também.
    </p>

    <h2>Interface</h2>
    <p>
      Uma outra forma de criar tipos são as Interfaces. Funciona da mesma forma
      que os Types e possuem quase a mesma construção, mas na interface não
      usamos o sinal de igual.
    </p>

    <h2>Type e Interface</h2>
    <p>
      Os dois servem para criar tipagem, o Type é mais recomendado por ser
      melhor para tipos primitivos e mais flexível. Interface normalmemnte é
      usada para programação orientada a objetos e não usa o sinal de igual.
      Para unir dois tipos usamos o E comercial, já na interface usamos extends.
    </p>

    <h2>tsconfig</h2>
    <p>
      Pode ser criado como JS ou JSON, ele serve para configurar o TS e
      conseguimos colocar todas as regras que o TS terá que seguir dentro da
      aplicação. Ao alterarmos ele pode restar apenas um lembrete, mas não um
      erro de sintaxe como normalmente.
    </p>

    <h2>Aplicando TypeScript</h2>
    <p>Agora iremos aplicar o TS no projeto do módulo anterior, número 3.</p>

    <h2>Projeto</h2>
    <p>
      Podemos fazer o download no github, mas como criei no módulo anterior,
      irei utilizar o meu próprio. Abrimos e iniciamos o projeto com o npm run
      dev.
    </p>

    <h2>Adicionando TypeScript</h2>
    <p>
      Instalamos o typescript no projeto via npm install typescript --save-dev,
      criamos o arquivo tsconfig.json e depois adicionamos as propriedades
      padrões dentro do typescript (na dúvida consultar a documentação).
    </p>

    <h2>Tipando Componente</h2>
    <p>
      Alteramos o nome do arquivo do componente Card de jsx para tsx para que o
      VS code identifique que se trata de um arquivo em typescript e não
      javascript. Após isso inserimos os tipos do card. Se necessário, instalar
      os tipos do TS para React usando npm i --save-dev @types/react.
    </p>

    <h2>Tipando Estados</h2>
    <p>
      No caso dos estamos, precisamos tipar o estado students que é o vetor que
      irá armazenar os valores de name e time dos cards. Para isso podemos
      exportar o type do card e importamos este tipo no index da home. Para
      informar no estado que estamos configurando o tipo em um vetor inserimos o
      seguinte texto após a função entre os sinais de maior e menor
      "Cardprops[]", abrindo e fechando chaves para indicar que se trata de um
      vetor.
    </p>

    <h2>Tipando Resposta da API</h2>
    <p>
      O TS não nos força a tipar tudo, mas podemos adicionar tipos numa resposta
      de API por exemplo. No caso, tipamos o retorno da API do github que
      estamos usando, tipando apenas para as propriedades que estamos usando
      adicionando "as ProfileResponse" ao final da linha do data. Adicionalmente
      podemos tipar nosso estado user para simplificarmos sua linha (para quando
      usarmos muitas propriedades) criando um tipo e com a adição do tipo de
      forma similar ao estado anterior mas agora tipando também o objeto dentro
      da função use state (verificar detalhes no arquivo index.tsx da página
      Home).
    </p>

    <h2>Encerramento</h2>
    <p>
      Fim das alterações do projeto, alteramos somente os tipos de card e home.
      Podemos aplicar o TS de forma gradativa em um projeto.
    </p>
  </body>
</html>
